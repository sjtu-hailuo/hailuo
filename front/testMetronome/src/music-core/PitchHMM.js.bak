const { Matrix } = require('ml-matrix');
const { Constants, Utils } = require('./utils');

const BINS_PER_SEMITONE = 5,
      LOWEST_PITCH = 28,    // E1
      HIGHEST_PITCH = 96,   // C7
      NSEMITONES = HIGHEST_PITCH - LOWEST_PITCH,
      NBINS = NSEMITONES * BINS_PER_SEMITONE,
      HMM_SIZE = 2 * NBINS,
      TRANS_WIDTH = 5 * Math.floor(BINS_PER_SEMITONE / 2) + 1, //(BINS_PER_SEMITONE & 1),
      YIN_TRUST = 0.5,
      SELF_TRANS = 0.99,
      VITERBI_SIZE = Constants.nHopsPitchDetectionDelay;

class PitchHMM {

  constructor(pitchSystem) {
    this.pitchSystem = pitchSystem;
    this.build();
    this.binFreq = new Array(2 * NBINS);
    this.binRealFreq = new Array(2 * NBINS);
    for (let i = 0; i < NBINS; i++) {
      this.binFreq[i] = this.pitchSystem.toFreq(i / BINS_PER_SEMITONE + LOWEST_PITCH);
      this.binFreq[i + NBINS] = - this.binFreq[i];
    }
    //console.log(this.binFreq);

    this.prevDelta = this.initial;
    this.count = 0;
    this.fromState = [];
    for (let i = 0; i < VITERBI_SIZE; i++) {
      this.fromState.push(new Array(HMM_SIZE).fill(0));
    }
  }

  build() {
    this.initial = new Array(HMM_SIZE).fill(1 / HMM_SIZE);

    this.transition = Matrix.zeros(HMM_SIZE, HMM_SIZE);
    const transWindow = Utils.genWindow(TRANS_WIDTH, 'triangle');
    for (let i = 0; i < NBINS; i++) {
      const halfTransWidth = Math.floor(TRANS_WIDTH / 2),
            minNextPitch = Math.max(i - halfTransWidth, 0),
            maxNextPitch = Math.min(i + halfTransWidth, NBINS - 1);
      const weights = Utils.normalizeArray(transWindow.slice(
          minNextPitch - i + halfTransWidth,
          maxNextPitch - i + halfTransWidth + 1
      ));
      for (let j = minNextPitch; j <= maxNextPitch; j++) {
        const curProb1 = weights[j - minNextPitch] * SELF_TRANS,
              curProb2 = weights[j - minNextPitch] * (1 - SELF_TRANS);
        this.transition.set(i, j, curProb1);
        this.transition.set(i, j + NBINS, curProb2);
        this.transition.set(i + NBINS, j, curProb2);
        this.transition.set(i + NBINS, j + NBINS, curProb1);
      }
    }

    //console.log(this.transition);
    // emission is a identital matrix which can be omitted.

  }

  calcObsProb(freqProb) {
    let obsProb = new Array(HMM_SIZE).fill(0),
        probYinPitched = 0;
    freqProb.forEach(([freq, prob]) => {
      if (freq < this.binFreq[0]) {
        return;
      }
      let prevd = Math.abs(freq - this.binFreq[0]);
      for (let i = 1; i < NBINS; i++) {
        const d = Math.abs(freq - this.binFreq[i]);
        if (prevd < d) {
          obsProb[i - 1] = prob * YIN_TRUST;
          this.binRealFreq[i - 1] = freq;
          probYinPitched += prob;
          break;
        }
        prevd = d;
      }
    });

    for (let i = 0; i < NBINS; i++) {
      obsProb[i + NBINS] = (1 - probYinPitched) / NBINS;
    }

    /*
    for (let i = 0; i < NBINS; i++) {
      if (obsProb[i] > 0) {
        console.log(this.binFreq[i], this.binRealFreq[i], obsProb[i]);
      }
    }
    */

    return obsProb;

  }

  viterbiAppend(obsProb) {
    let delta = new Array(HMM_SIZE).fill(0);
    for (let i = 0; i < HMM_SIZE; i++) {
      for (let j = 0; j < HMM_SIZE; j++) {
        const curValue = this.prevDelta[i] * this.transition.get(i, j);
        if (curValue > delta[j]) {
          delta[j] = curValue;
          this.fromState[this.count % VITERBI_SIZE][j] = i;
        }
      }
    }

    for (let i = 0; i < HMM_SIZE; i++) {
      delta[i] *= obsProb[i];
    }

    this.prevDelta = Utils.normalizeArray(delta);
    //console.log(this.prevDelta);
    this.count += 1;
  }

  viterbiBackward() {
    if (this.count < VITERBI_SIZE) {
      return null;
    }
    let bestValue = 0, resBin = null;
    for (let i = 0; i < HMM_SIZE; i++) {
      if (this.prevDelta[i] > bestValue) {
        bestValue = this.prevDelta[i];
        resBin = i;
      }
    }
    if (resBin === null) {
      return null;
    }
    for (let i = 0; i < VITERBI_SIZE; i++) {
      resBin = this.fromState[(this.count - i) % VITERBI_SIZE][resBin];
    }

    //return this.binRealFreq[resBin] > 0 ? this.binRealFreq[resBin] : this.binFreq[resBin];
    return this.binFreq[resBin];
  }

  append(freqProb) {
    this.viterbiAppend(this.calcObsProb(freqProb));
    const binFreq = this.viterbiBackward();
    let minDist = 1 / BINS_PER_SEMITONE,
        resFreq = null;
    freqProb.forEach(([freq, prob]) => {
      const dist = Math.abs(
        this.pitchSystem.toMidi(freq) -
        this.pitchSystem.toMidi(binFreq)
      );
      if (dist < minDist) {
        minDist = dist;
        resFreq = freq;
      }
    });
    return resFreq;
  }

};

module.exports = PitchHMM;
